当类没有任何地方引用的时候，包括类加载器自身也被回收的时候，类就被卸载了。
编译器优化的时候，有可能超出作用域的对象，其本地变量表会被重复利用，从而协助gc收集器回收。显式赋值null不优雅。
问题及记录
1、先向os申请内存，然后把内存分为几个区域
2、静态成员存在哪？String和其他对象在方法区吗？还是有一部分放到了堆?
3、jvm把本地方法和java方法的栈合二为一了
4、jvm的方法栈，从哪申请的（同时要注意，栈区的空间 JVM 没有办法去限制的，因为 JVM 在运行过程中会有线程不断的运行，没办法限制，所以只限制单个虚拟机栈的大小。）
5、内存溢出的四种：栈、堆、方法（java8已经移动到堆）、直接内存
6、<<Reverse pointers>>: 表示被谁引用了
7、whatis 0x0000000012c14840
Address 0x0000000012c14840: In thread-local allocation buffer for thread "main" (4)  [0x0000000012c111b8,0x0000000012c14850,0x0000000012c1ea00,{0x0000000012c1ea18})
:: 线程 TLAB 内分配的空间
8、我们平时写的java类编译成.class文件，JVM加载.class文件，那么加载.class文件之后在JVM中就是oop-kclass（C++）模型形式存在的。
9、hsdb看到的是jvm内部c++的状态
10、HotSpot并不把instanceKlass暴露给Java，而会另外创建对应的instanceOopDesc来表示java.lang.Class对象，并将后者称为前者的“Java镜像”就是图中看到的'_java_mirror'属性。
instanceOopDesc中的_metadata成员，它是联合体，可以表示未压缩的Klass指针(_klass)和压缩的Klass指针。对应的klass指针指向一个存储类的元数据的Klass对象
11、hsdb既可以查看java对象、元数据之间的关系，又可以查看jvm内部c++结构、对象之间的关系。
12、Hotspot没有把其内部核心的数据结构直接开放，而是使用了另外一个傀儡拷贝对外开放。
12、class brownser里面的类、


Klass 系对象，用于描述类型的总体信息【通过 OOP 信息（inspect）可以看到 instanceKlass 对象】

ConstantPool/ConstantPoolCache 对象：每个 InstanceKlass 关联着一个 ConstantPool，作为该类型的运行时常量池。这个常量池的结构跟 Class 文件里的常量池基本上是对应的


public class StringTest {
    private String val1 = "a";
    private static String val2 = StringTest.class.getName() + "b";
    private static WeakReference val3 = new WeakReference(StringTest.class.getName() + "b");

    public static void main(String args[]) {
        StringTest st = new StringTest();
        String a = "a";
        String d = "a";
        String b = a + "b";
        String c = "a" + "b";
        String e = "ab";
        System.out.println(a + b + c + d + e);
    }
}



StringTest对象：0x0000000011c0ddf8
   _metadata:InstanceKlass地址：0x0000000012a14750 jvm内部InstanceKlass对象
        _mirror: Oop for java/lang/Class @ 0x0000000011c09308  Class对象
		    _metadata:0x0000000012614158  jvm内部InstanceMirrorKlass对象
				_mirror:特殊的Class对象
		    静态对象WeakReference对象地址：0x0000000011c0dc90
               _metadata:InstanceRefKlass地址：0x000000001262f230
                    _mirror:: Oop for java/lang/Class @ 0x0000000011f175d0 Class对象
                        _metadata:0x0000000012614158 jvm内部InstanceMirrorKlass对象
            				_mirror:特殊的Class对象
            静态String对象"stringtest.StringTestb" @ 0x0000000011c0d9e8		
                _metadata:InstanceKlass地址：0x0000000012609010 jvm内部InstanceKlass对象
				    _mirror: Oop for java/lang/Class @ 0x0000000011f1a598  Class对象 
                        _metadata:0x0000000012614158  jvm内部InstanceMirrorKlass对象	
						    _mirror:特殊的Class对象
							
							
							







assert true | false
attach pid | exec core  连接
detach 断开
reattach
buildreplayjars [ all | app | boot ]  | [ prefix ]  不知道干啥的
scanoops start end [ type ] 在堆栈中检索某个类型的对象
jhisto 对象直方图
inspect expression 和图形化界面功能一样
revptrs address 使用一个对象地址，反向找对象被谁引用
thread { -a | id } 显示线程的基本信息，
threads
universe 堆栈汇总信息，与图形化功能heap parameter一样
jdis address 地址是某个Method的地址，在图形化界面class brownser能找到
disassemble address 和图形化功能code viewer一样
history 历史命令
help [ command ]
quit退出


  dis address [length]
  dumpcfg { -a | id }
  dumpcodecache
  dumpideal { -a | id }
  dumpilt { -a | id }
  dumpreplaydata { <address > | -a | <thread_id> }
  echo [ true | false ]
  examine [ address/count ] | [ address,address]
  field [ type [ name fieldtype isStatic offset address ] ]
  findpc address
  flags [ flag | -nd 
  intConstant [ name [ value ] ]
  jstack [-v]
  livenmethods
  longConstant [ name [ value ] ]
  pmap
  print expression  
  printall  慎用，不要用打印内容太多
  printas type expression
  printmdo [ -a | expression ]
  printstatics [ type ]
  pstack [-v]
  search [ heap | perm | rawheap | codecache | threads ] value
  source filename
  symbol address
  symboldump
  symboltable name
  tokenize ...
  type [ type [ name super isOop isInteger isUnsigned size ] ]
  
  verbose true | false
  versioncheck [ true | false ]
  vmstructsdump
  where { -a | id }
