1、gc的吞吐量和带宽的吞吐量不一样
2、Full GC是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC。Full GC不等于Major GC，也不等于Minor GC+Major GC，发生Full GC需要看使用了什么垃圾收集器组合，才能解释是什么样的垃圾回收。
3、统计YGC发生时晋升到老年代的平均总大小大于老年代的空闲空间。在发生YGC是会判断，是否安全，这里的安全指的是，当前老年代空间可以容纳YGC晋升的对象的平均大小，如果不安全，就不会执行YGC,转而执行FullGC。
4、你也可以从full GC 的效果来推断问题，正常情况下，一次full GC应该会回收大量内存，所以正常的堆内存曲线应该是呈锯齿形。如果你发现full gc 之后堆内存几乎没有下降，那么可以推断：堆中有大量不能回收的对象且在不停膨胀，使堆的使用占比超过full GC的触发阈值，但又回收不掉，导致full GC一直执行。换句话来说，可能是内存泄露了。
5、full gc频繁的可能原因
大对象：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代；
内存泄漏：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM
程序频繁生成一些长生命周期的对象，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC
程序BUG导致动态生成了很多新类，使得 Metaspace 不断被占用，先引发FGC，最后导致OOM
代码中显式调用了gc方法，包括自己的代码甚至框架中的代码；此时可能是显示的System.gc()调用导致GC次数过多，这可以通过添加-XX:+DisableExplicitGC来禁用JVM对显示GC的响应
JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等
6、XX:MaxMetaspaceSize=512M -XX:MetaspaceSize=512M 
7、Xmx与Xms 一般实际生产应用中，Xms与Xmx设置为同一个值，避免JVM GC频繁缩容扩容
8、-Xcomp
关闭解释器，不要进行解释执行，或者叫作最大优化级别；“-Xcomp”会导致 JVM 启动变慢非常多，同时有些JIT 编译器优化方式，比如分支预测，如果不进行 profiling，往往并不能进行有效优化
9、serial提升失败会引发full gc
[GC (Allocation Failure) [DefNew (promotion failed) : 8841K->8586K(8960K), 0.0075135 secs][Tenured: 10228K->10228K(10240K), 0.0066546 secs] 12925K->12788K(19200K), [Metaspace: 3978K->3978K(1056768K)], 0.0143042 secs] [Times: user=0.00 sys=0.01, real=0.01 secs] 
