当类没有任何地方引用的时候，包括类加载器自身也被回收的时候，类就被卸载了。
编译器优化的时候，有可能超出作用域的对象，其本地变量表会被重复利用，从而协助gc收集器回收。显式赋值null不优雅。
问题及记录
1、先向os申请内存，然后把内存分为几个区域
2、静态成员存在哪？String和其他对象在方法区吗？还是有一部分放到了堆?
3、jvm把本地方法和java方法的栈合二为一了
4、jvm的方法栈，从哪申请的（同时要注意，栈区的空间 JVM 没有办法去限制的，因为 JVM 在运行过程中会有线程不断的运行，没办法限制，所以只限制单个虚拟机栈的大小。）
5、内存溢出的四种：栈、堆、方法（java8已经移动到堆）、直接内存
6、<<Reverse pointers>>: 表示被谁引用了
7、whatis 0x0000000012c14840
Address 0x0000000012c14840: In thread-local allocation buffer for thread "main" (4)  [0x0000000012c111b8,0x0000000012c14850,0x0000000012c1ea00,{0x0000000012c1ea18})
:: 线程 TLAB 内分配的空间
8、我们平时写的java类编译成.class文件，JVM加载.class文件，那么加载.class文件之后在JVM中就是oop-kclass（C++）模型形式存在的。
9、hsdb看到的是jvm内部c++的状态
10、HotSpot并不把instanceKlass暴露给Java，而会另外创建对应的instanceOopDesc来表示java.lang.Class对象，并将后者称为前者的“Java镜像”就是图中看到的'_java_mirror'属性。
instanceOopDesc中的_metadata成员，它是联合体，可以表示未压缩的Klass指针(_klass)和压缩的Klass指针。对应的klass指针指向一个存储类的元数据的Klass对象
11、hsdb既可以查看java对象、元数据之间的关系，又可以查看jvm内部c++结构、对象之间的关系。
12、Hotspot没有把其内部核心的数据结构直接开放，而是使用了另外一个傀儡拷贝对外开放。
12、class brownser里面的类、


find pointer : 查找一个地址，看这个地址是在新生代、老年代
classes、class 类全名，功能和class browser一样
print 输入Klass*, Method*等地址，效果同Code Viewer菜单
where 输入线程id，查看该线程的调用栈，输入-a，查看所有线程的调用栈，效果同show java stack trace
printmdo 用于打印指定地址的MethodData对象，该对象保存了Profile统计的方法性能的数据
printstatics 可以用于获取Hotspot 定义的C++类的静态属性，如表示Java堆内存的Universe对象
printas 后跟一个Hotspot Type和地址，会打印该Type对象的各属性，效果同inspect命令，不过不局限与oop，也可以是对象的真实地址。
findpc address 检查pc的状态，pc的值可以从线程的信息中拿到
assert false\true hotspot开启或者关闭断言
whatis  地址，返回一个地址存放的类型，几乎任何类型都可以，包括指针、对象、Klass对象、Method、ConstantPool、Field等的地址



1、类继承时，扫描堆区用基类一样能把子类都扫描出来。
2、Class文件中有个静态常量池，加载成功后，静态常量池中的符号引用转化为直接引用并对接运行时常量池的过程称为解析。当符号引用首次被访问时才去解析（Hotspot，不同JVM有不同实现）。
3、jdb命令也可以进行debug，和idea用的是同一套Java API
4、


public class StringTest {
    private String val1 = "a";
    private static String val2 = StringTest.class.getName() + "b";
    private static WeakReference val3 = new WeakReference(StringTest.class.getName() + "b");

    public static void main(String args[]) {
        StringTest st = new StringTest();
        String a = "a";
        String d = "a";
        String b = a + "b";
        String c = "a" + "b";
        String e = "ab";
        System.out.println(a + b + c + d + e);
    }
}



StringTest对象：0x0000000011c0ddf8
   _metadata:InstanceKlass地址：0x0000000012a14750 jvm内部InstanceKlass对象
        _mirror: Oop for java/lang/Class @ 0x0000000011c09308  Class对象
		    _metadata:0x0000000012614158  jvm内部InstanceMirrorKlass对象
				_mirror: Oop for java/lang/Class @ 0x0000000011f1d468 Class对象
					_metadata:0x0000000012614158  指回到了InstanceMirrorKlass对象	
		    静态对象WeakReference对象地址：0x0000000011c0dc90
               _metadata:InstanceRefKlass地址：0x000000001262f230
                    _mirror:: Oop for java/lang/Class @ 0x0000000011f175d0 Class对象
                        _metadata:0x0000000012614158 jvm内部InstanceMirrorKlass对象
            				_mirror: Oop for java/lang/Class @ 0x0000000011f1d468 Class对象
								_metadata:0x0000000012614158  指回到了InstanceMirrorKlass对象	
            静态String对象"stringtest.StringTestb" @ 0x0000000011c0d9e8		
                _metadata:InstanceKlass地址：0x0000000012609010 jvm内部InstanceKlass对象
				    _mirror: Oop for java/lang/Class @ 0x0000000011f1a598  Class对象 
                        _metadata:0x0000000012614158  jvm内部InstanceMirrorKlass对象	
						    _mirror: Oop for java/lang/Class @ 0x0000000011f1d468 Class对象
								_metadata:0x0000000012614158  指回到了InstanceMirrorKlass对象	
							
						







assert true | false
attach pid | exec core  连接
detach 断开
reattach
buildreplayjars [ all | app | boot ]  | [ prefix ]  不知道干啥的
scanoops start end [ type ] 在堆栈中检索某个类型的对象
jhisto 对象直方图
inspect expression 和图形化界面功能一样
revptrs address 使用一个对象地址，反向找对象被谁引用
thread { -a | id } 显示线程的基本信息，
threads
universe 堆栈汇总信息，与图形化功能heap parameter一样
jdis address 地址是某个Method的地址，在图形化界面class brownser能找到
disassemble address 和图形化功能code viewer一样
history 历史命令
help [ command ]
quit退出


  dis address [length]
  dumpcfg { -a | id }
  dumpcodecache
  dumpideal { -a | id }
  dumpilt { -a | id }
  dumpreplaydata { <address > | -a | <thread_id> }
  echo [ true | false ]
  examine [ address/count ] | [ address,address]
  field [ type [ name fieldtype isStatic offset address ] ]
  findpc address
  flags [ flag | -nd 
  intConstant [ name [ value ] ]
  jstack [-v]
  livenmethods
  longConstant [ name [ value ] ]
  pmap
  print expression  
  printall  慎用，不要用打印内容太多
  printas type expression
  printmdo [ -a | expression ]
  printstatics [ type ]
  pstack [-v]
  search [ heap | perm | rawheap | codecache | threads ] value
  source filename
  symbol address
  symboldump
  symboltable name
  tokenize ...
  type [ type [ name super isOop isInteger isUnsigned size ] ]
  
  verbose true | false
  versioncheck [ true | false ]
  vmstructsdump
  where { -a | id }
